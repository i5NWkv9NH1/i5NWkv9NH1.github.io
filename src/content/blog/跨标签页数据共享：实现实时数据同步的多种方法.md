---
title: è·¨æ ‡ç­¾é¡µæ•°æ®å…±äº«ï¼šå®ç°å®æ—¶æ•°æ®åŒæ­¥çš„ç­–ç•¥
---

## å‰è¨€

åœ¨å¼€å‘ Vue.js åº”ç”¨æ—¶ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°è¿™æ ·çš„åœºæ™¯ï¼šæœ‰ä¸¤ä¸ªæ ‡ç­¾é¡µï¼Œä¸€ä¸ªæ˜¾ç¤ºæ•°æ®è¡¨æ ¼ï¼ˆå¢åˆ æ”¹æŸ¥ï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¾ç¤ºå•ä¸ªæ•°æ®é¡¹çš„è¯¦ç»†ä¿¡æ¯ã€‚å½“æˆ‘ä»¬åœ¨è¯¦æƒ…é¡µä¿®æ”¹æ•°æ®å¹¶æäº¤åï¼Œå¸Œæœ›ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µçš„è¡¨æ ¼å¯ä»¥è‡ªåŠ¨åˆ·æ–°ï¼Œæ˜¾ç¤ºæœ€æ–°çš„æ•°æ®ã€‚ä»Šå¤©ï¼Œæˆ‘å°†å’Œå¤§å®¶åˆ†äº«å‡ ç§å®ç”¨çš„æ–¹æ³•æ¥å®ç°è¿™ä¸€éœ€æ±‚ï¼Œå¹¶è§£é‡Šä¸ºä»€ä¹ˆ Vuex å’Œ Pinia è¿™æ ·çš„çŠ¶æ€ç®¡ç†å·¥å…·æ— æ³•ç›´æ¥æ»¡è¶³è¿™ä¸ªåœºæ™¯ã€‚

## ğŸ’¡ Vuex å’Œ Piniaï¼šè·¨æ ‡ç­¾é¡µçŠ¶æ€ç®¡ç†çš„å°éš¾é¢˜

Vuex å’Œ Pinia æ˜¯ Vue.js ä¸­å¸¸ç”¨çš„çŠ¶æ€ç®¡ç†å·¥å…·ï¼Œå®ƒä»¬åœ¨ç®¡ç†å•ä¸ª Vue åº”ç”¨å†…çš„çŠ¶æ€æ—¶éå¸¸æœ‰æ•ˆã€‚ä½†é—®é¢˜åœ¨äºï¼Œå½“æˆ‘ä»¬æ‰“å¼€å¤šä¸ªæ ‡ç­¾é¡µæ—¶ï¼Œæ¯ä¸ªæ ‡ç­¾é¡µéƒ½æœ‰è‡ªå·±çš„ç‹¬ç«‹çŠ¶æ€ã€‚Vuex å’Œ Pinia çš„çŠ¶æ€ä¿å­˜åœ¨ JavaScript å†…å­˜ä¸­ï¼Œæ— æ³•è·¨æ ‡ç­¾é¡µå…±äº«ã€‚è¿™æ„å‘³ç€ä½ åœ¨ä¸€ä¸ªæ ‡ç­¾é¡µä¸­ä¿®æ”¹çŠ¶æ€æ—¶ï¼Œå¦ä¸€ä¸ªæ ‡ç­¾é¡µä¸ä¼šè‡ªåŠ¨æ„ŸçŸ¥åˆ°è¿™äº›å˜åŒ–ã€‚

## è§£å†³æ–¹æ¡ˆ

### BroadcastChannel API

**BroadcastChannel API** æ˜¯ä¸€ç§æµè§ˆå™¨åŸç”Ÿæ”¯æŒçš„APIï¼Œå…è®¸åœ¨åŒä¸€æµè§ˆå™¨ä¸­çš„ä¸åŒæ ‡ç­¾é¡µæˆ– iframe ä¹‹é—´ä¼ é€’æ¶ˆæ¯ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•ä¸”é«˜æ•ˆçš„è§£å†³æ–¹æ¡ˆï¼Œéå¸¸é€‚åˆè¿™ä¸€ä¸ªä¸šåŠ¡åœºæ™¯ã€‚

**ä½¿ç”¨æ­¥éª¤ï¼š**

1. åœ¨æ¯ä¸ªæ ‡ç­¾é¡µä¸­åˆ›å»ºä¸€ä¸ª `BroadcastChannel` å®ä¾‹ã€‚
2. åœ¨è¯¦æƒ…é¡µä¸­ä¿®æ”¹æ•°æ®åï¼Œå‘é¢‘é“å‘é€æ¶ˆæ¯ã€‚
3. è¡¨æ ¼é¡µç›‘å¬åˆ°æ¶ˆæ¯åï¼Œè§¦å‘æ•°æ®åˆ·æ–°ã€‚

**ä»£ç ç¤ºä¾‹ï¼š**

```ts
// broadcast-channel.ts
export class BroadcastChannelService {
  private channel: BroadcastChannel;

  constructor(channelName: string) {
    this.channel = new BroadcastChannel(channelName);
  }

  // å‘é€æ¶ˆæ¯
  sendMessage(message: any) {
    this.channel.postMessage(message);
  }

  // ç›‘å¬æ¶ˆæ¯
  onMessage(callback: (event: MessageEvent) => void) {
    this.channel.onmessage = callback;
  }

  // å…³é—­é¢‘é“
  close() {
    this.channel.close();
  }
}
```

```vue
<!-- TablePage -->
<template>
  <table>
    <!-- è¡¨æ ¼æ•°æ® -->
  </table>
</template>

<script lang="ts" setup>
import { BroadcastChannelService } from './broadcast-channel';

const data = ref<any[]>([]);
const channelService = new BroadcastChannelService('data-sync');

// ç›‘å¬æ¶ˆæ¯ï¼Œæ¥æ”¶åˆ°åˆ·æ–°æŒ‡ä»¤æ—¶é‡æ–°è·å–æ•°æ®
onMounted(() => {
  channelService.onMessage((event) => {
    if (event.data === 'refresh') {
      fetchData();
    }
  });

  fetchData();
});

// æ¨¡æ‹Ÿè·å–æ•°æ®çš„å‡½æ•°
const fetchData = () => {
  // å‡è®¾ä» API è·å–æ•°æ®
  data.value = [
    { id: 1, name: 'æ•°æ®1' },
    { id: 2, name: 'æ•°æ®2' },
    // ...å…¶ä»–æ•°æ®
  ];
};
</script>

```

```Vue
<!-- DetailPage -->
<template>
  <button @click="updateData">æäº¤</button>
</template>

<script lang="ts" setup>
import { BroadcastChannelService } from './broadcast-channel';

// åˆ›å»º BroadcastChannelService å®ä¾‹
const channelService = new BroadcastChannelService('data-sync');

// æ¨¡æ‹Ÿæ•°æ®æ›´æ–°çš„å‡½æ•°
const updateData = () => {
  // å‡è®¾æ›´æ–°æ•°æ®
  // ...

  // å‘é€åˆ·æ–°æŒ‡ä»¤
  channelService.sendMessage('refresh');
};
</script>

```

### WebSocket

ä½¿ç”¨ WebSocket å¯ä»¥å®ç°å®æ—¶çš„åŒå‘é€šä¿¡ï¼Œé€‚åˆéœ€è¦é¢‘ç¹æ•°æ®åŒæ­¥çš„åœºæ™¯ã€‚é€šè¿‡åç«¯ï¼ˆä¾‹å¦‚ä½¿ç”¨Nest.jsï¼‰æ­å»º WebSocket æœåŠ¡å™¨ï¼Œå¯ä»¥åœ¨å‰ç«¯å¤šä¸ªæ ‡ç­¾é¡µä¹‹é—´å®æ—¶åŒæ­¥æ•°æ®ã€‚

**ä½¿ç”¨æ­¥éª¤ï¼š**

1. åœ¨åç«¯æ­å»º WebSocket æœåŠ¡å™¨ã€‚
2. å‰ç«¯å»ºç«‹ WebSocket è¿æ¥ã€‚
3. è¯¦æƒ…é¡µä¿®æ”¹æ•°æ®åï¼Œé€šè¿‡ WebSocket å‘æœåŠ¡å™¨å‘é€æ›´æ–°é€šçŸ¥ã€‚
4. æœåŠ¡å™¨å°†æ›´æ–°æ¶ˆæ¯å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯ã€‚

**ä»£ç ç¤ºä¾‹ï¼š**

```ts
// Nest.js
// websocket.gateway.ts
import { WebSocketGateway, OnGatewayConnection, OnGatewayDisconnect, WebSocketServer } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

@WebSocketGateway()
export class WebSocketGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  handleConnection(client: Socket) {
    console.log('Client connected:', client.id);
  }

  handleDisconnect(client: Socket) {
    console.log('Client disconnected:', client.id);
  }

  sendUpdate(data: any) {
    this.server.emit('update', data);
  }
}

```

```vue
<!-- TablePage -->
<template>
  <table>
    <!-- è¡¨æ ¼æ•°æ® -->
  </table>
</template>

<script lang="ts" setup>
import { ref, onMounted } from 'vue';
import io from 'socket.io-client';

const data = ref<any[]>([]);
const socket = io('http://localhost:3000');

onMounted(() => {
  socket.on('update', () => {
    fetchData();
  });

  fetchData();
});

const fetchData = () => {
  // å‡è®¾ä» API è·å–æ•°æ®
  data.value = [
    { id: 1, name: 'æ•°æ®1' },
    { id: 2, name: 'æ•°æ®2' },
    // ...å…¶ä»–æ•°æ®
  ];
};

// åœ¨è¯¦æƒ…é¡µä¸­ï¼Œå½“æ•°æ®æ›´æ–°åé€šçŸ¥æœåŠ¡å™¨
const updateData = () => {
  const updatedData = { /* ... */ };
  socket.emit('update', updatedData);
};
</script>
```

```vue
<!-- DetailPage -->
<template>
  <button @click="handleSubmit">æäº¤</button>
</template>

<script lang="ts" setup>
import io from 'socket.io-client';

// æ•°æ®é¡¹
const item = ref<any>({ id: 1, name: '', value: '' });

// è¿æ¥åˆ° WebSocket æœåŠ¡å™¨
const socket = io('http://localhost:3000');

// æäº¤æ›´æ–°
const handleSubmit = async () => {
  const updatedData = { id: item.value.id, name: item.value.name, value: item.value.value };
  
  // å‘é€æ›´æ–°æ•°æ®åˆ°æœåŠ¡å™¨
  socket.emit('update', updatedData);
};
</script>

```



### Service Worker

**Service Worker** ä¸»è¦ç”¨äºå¤„ç†åå°ä»»åŠ¡ï¼Œæ¯”å¦‚ç¦»çº¿æ”¯æŒå’Œç¼“å­˜ç®¡ç†ã€‚å®ƒå¯ä»¥åœ¨åå°çº¿ç¨‹ä¸­è¿è¡Œï¼Œå¹¶ä¸”ä¸é¡µé¢çº¿ç¨‹éš”ç¦»ã€‚

**ä½¿ç”¨æ­¥éª¤ï¼š**

1. æ³¨å†Œå’Œé…ç½® Service Workerã€‚
2. åœ¨ Vue ç»„ä»¶ä¸­æ·»åŠ ç›‘å¬å¹¶è°ƒç”¨äº‹ä»¶ã€‚

**ä»£ç ç¤ºä¾‹ï¼š**

```ts
// main.ts
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').then((registration) => {
    console.log('Service Worker registered with scope:', registration.scope);
  }).catch((error) => {
    console.error('Service Worker registration failed:', error);
  });
}
```

```ts
// service-worker.js
self.addEventListener('install', (event) => {
  console.log('Service Worker installing.');
  // è¿™é‡Œå¯ä»¥æ·»åŠ ç¼“å­˜é€»è¾‘
});

self.addEventListener('fetch', (event) => {
  console.log('Service Worker fetching:', event.request.url);
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

self.addEventListener('message', (event) => {
  if (event.data.type === 'CHECK_FOR_UPDATES') {
    // å‡è®¾æ•°æ®å·²æ›´æ–°
    event.waitUntil(
      // 
      self.clients.matchAll().then((clients) => {
        clients.forEach(client => client.postMessage({ type: 'UPDATE_DATA' }));
      })
    );
  }
});

```

```vue
<!-- DetailPage.vue -->
<template>
  <button @click="handleSubmit">æäº¤</button>
</template>

<script lang="ts" setup>
const handleSubmit = () => {
  if (navigator.serviceWorker.controller) {
    navigator.serviceWorker.controller.postMessage({ type: 'CHECK_FOR_UPDATES' });
  }
};
</script>
```

```vue
<!-- TablePage.vue -->
<template>
  <table>
    <!-- è¡¨æ ¼æ•°æ® -->
  </table>
</template>

<script lang="ts" setup>
const fetchData = async () => {
  // ä»æœåŠ¡å™¨è·å–æ•°æ®å¹¶æ›´æ–°è¡¨æ ¼
};

onMounted(() => {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.addEventListener('message', (event) => {
      if (event.data.type === 'UPDATE_DATA') {
        fetchData(); // åˆ·æ–°æ•°æ®
      }
    });
  }
});
</script>
```

### Shared Worker

**Shared Worker** å…è®¸å¤šä¸ªæ ‡ç­¾é¡µå…±äº«ä¸€ä¸ªåå°çº¿ç¨‹ã€‚é€šè¿‡å¯¹ shared worker ç›‘å¬äº‹ä»¶ï¼Œå¯ä»¥å®šæœŸæ£€æŸ¥æ•°æ®å˜åŒ–å¹¶é€šçŸ¥æ ‡ç­¾é¡µã€‚

**ä½¿ç”¨æ­¥éª¤ï¼š**

1. åˆ›å»ºä¸€ä¸ª Shared Worker æ¥å…±äº«æ•°æ®ã€‚
2. ä½¿ç”¨å®šæ—¶å™¨å®šæœŸå‘ Shared Worker æŸ¥è¯¢æ•°æ®å˜åŒ–ã€‚
3. å½“æ•°æ®å˜åŒ–æ—¶ï¼Œé€šçŸ¥ç›¸å…³çš„æ ‡ç­¾é¡µåˆ·æ–°æ•°æ®ã€‚

**ä»£ç ç¤ºä¾‹ï¼š**

```ts
// shared-worker.js
let connections = [];

self.onconnect = (event) => {
  const port = event.ports[0];
  connections.push(port);

  port.addEventListener('message', (event) => {
    if (event.data.type === 'CHECK_FOR_UPDATES') {
      // æ£€æŸ¥æ•°æ®æ˜¯å¦æ›´æ–°çš„é€»è¾‘
      const dataUpdated = true; // å‡è®¾æ•°æ®å·²æ›´æ–°
      if (dataUpdated) {
        connections.forEach(client => client.postMessage({ type: 'UPDATE_DATA' }));
      }
    }
  });

  port.start();
};
```

```vue
<!-- åœ¨ Vue ç»„ä»¶ä¸­ä½¿ç”¨ Shared Worker -->
<!-- DetailPage.vue -->
<template>
  <button @click="handleSubmit">æäº¤</button>
</template>

<script lang="ts" setup>
const handleSubmit = () => {
  const worker = new SharedWorker('shared-worker.js');
  worker.port.postMessage({ type: 'CHECK_FOR_UPDATES' });
};
</script>

```

```vue
<!-- TablePage -->
<script lang="ts" setup>
const fetchData = async () => {
  // ä»æœåŠ¡å™¨è·å–æ•°æ®å¹¶æ›´æ–°è¡¨æ ¼
};

onMounted(() => {
  const worker = new SharedWorker('shared-worker.js');
  worker.port.addEventListener('message', (event) => {
    if (event.data.type === 'UPDATE_DATA') {
      fetchData(); // åˆ·æ–°æ•°æ®
    }
  });
  worker.port.start();
});
</script>
```

### ä½¿ç”¨ IndexedDB å’Œå®šæ—¶å™¨è½®è¯¢

`IndexedDB` æ˜¯ä¸€ç§æµè§ˆå™¨å†…ç½®çš„æ•°æ®åº“ï¼Œé€‚ç”¨äºå­˜å‚¨å¤§é‡ç»“æ„åŒ–æ•°æ®ã€‚ç»“åˆå®šæ—¶å™¨è½®è¯¢æ¥å®šæœŸæ£€æŸ¥æ•°æ®æ˜¯å¦æœ‰æ›´æ–°ï¼Œè¿™å¯ä»¥ç¡®ä¿é¡µé¢å±•ç¤ºçš„æ•°æ®æ˜¯æœ€æ–°çš„ã€‚

**ä½¿ç”¨æ­¥éª¤ï¼š**

1. **é…ç½® IndexedDB æ•°æ®åº“**ï¼š åˆ›å»ºä¸€ä¸ª `IndexedDB` æ•°æ®åº“ï¼Œå¹¶å®šä¹‰ä¸€ä¸ªå­˜å‚¨å¯¹è±¡æ¥å­˜å‚¨æ•°æ®ã€‚ç¡®ä¿åœ¨æ•°æ®åº“çš„å‡çº§é˜¶æ®µåˆ›å»ºæ•°æ®å­˜å‚¨å¯¹è±¡ã€‚
2. **åœ¨ Vue ç»„ä»¶ä¸­ä½¿ç”¨å®šæ—¶å™¨è½®è¯¢**ï¼š åœ¨ Vue ç»„ä»¶ä¸­è®¾ç½®å®šæ—¶å™¨ï¼Œæ¯éš”ä¸€å®šæ—¶é—´ä»æ•°æ®åº“ä¸­è¯»å–æ•°æ®å¹¶æ›´æ–°ç»„ä»¶ä¸­çš„çŠ¶æ€ã€‚

```ts
// db.ts
export const openDb = async () => {
  return new Promise<IDBDatabase>((resolve, reject) => {
    const request = indexedDB.open('myDatabase', 1);
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      db.createObjectStore('dataStore', { keyPath: 'id' });
    };
    request.onsuccess = (event) => resolve((event.target as IDBOpenDBRequest).result);
    request.onerror = (event) => reject((event.target as IDBOpenDBRequest).error);
  });
};

export const fetchDataFromDb = async () => {
  const db = await openDb();
  return new Promise<any[]>((resolve, reject) => {
    const transaction = db.transaction('dataStore', 'readonly');
    const store = transaction.objectStore('dataStore');
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

```

```vue
<!-- TablePage.vue -->
<!-- ä¸»é¡µé¢ä¸­ä½¿ç”¨å®šæ—¶å™¨è½®è¯¢ -->
<template>
  <table>
    <!-- æ•°æ®è¡¨æ ¼ -->
  </table>
</template>

<script lang="ts" setup>
import { fetchDataFromDb } from './db';

const data = ref<any[]>([]);

const fetchData = async () => {
  data.value = await fetchDataFromDb();
};

onMounted(() => {
  fetchData(); // åˆæ¬¡åŠ è½½æ•°æ®
  setInterval(fetchData, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡æ›´æ–°
});
</script>

```

```vue
<!-- DetailPage.vue -->
<template>
  <button @click="handleSubmit">æäº¤</button>
</template>

<script lang="ts" setup>
import { updateDataInDb } from './db';

const item = ref<any>({ id: 1, name: '', value: '' }); // ç¤ºä¾‹æ•°æ®

const handleSubmit = async () => {
  await updateDataInDb(item.value);
  if (window.opener) {
    window.opener.postMessage({ type: 'UPDATE_DATA' }, '*');
  }
};
</script>

```

### ä½¿ç”¨ window.open å’Œ window.postMessage

åœ¨ä¸»é¡µé¢ä¸­æ‰“å¼€ä¸€ä¸ªå­çª—å£ï¼Œå½“å­çª—å£ä¸­çš„æ•°æ®æ›´æ–°æ—¶ï¼Œéœ€è¦é€šçŸ¥ä¸»é¡µé¢è¿›è¡Œåˆ·æ–°ã€‚

**ä½¿ç”¨æ­¥éª¤**ï¼š

1. **åœ¨å­çª—å£ä¸­å‘é€æ¶ˆæ¯**ï¼š åœ¨å­çª—å£æ›´æ–°æ•°æ®æ—¶ï¼Œä½¿ç”¨ `window.postMessage` å‘é€æ¶ˆæ¯åˆ°ä¸»çª—å£ã€‚
2. **åœ¨ä¸»çª—å£ä¸­å¤„ç†æ¶ˆæ¯**ï¼š åœ¨ä¸»çª—å£ä¸­ç›‘å¬æ¥è‡ªå­çª—å£çš„æ¶ˆæ¯ï¼Œæ”¶åˆ°æ¶ˆæ¯åæ›´æ–°æ•°æ®ã€‚

**ä»£ç ç¤ºä¾‹**ï¼š

```vue
<!-- åœ¨å­çª—å£ä¸­å‘é€æ¶ˆæ¯ -->
<!-- DetailPage.vue -->
<template>
  <button @click="handleSubmit">æäº¤</button>
</template>

<script lang="ts" setup>
import { updateDataInDb } from './db';

const item = ref<any>({ id: 1, name: '', value: '' }); // ç¤ºä¾‹æ•°æ®

const handleSubmit = async () => {
  await updateDataInDb(item.value);
  if (window.opener) {
    window.opener.postMessage({ type: 'UPDATE_DATA' }, '*');
  }
};
</script>

```

```vue
<!-- åœ¨ä¸»çª—å£ä¸­å¤„ç†æ¶ˆæ¯ -->
// TablePage.vue
<template>
  <table>
   	<!-- è¡¨æ ¼æ•°æ® -->
  </table>
</template>

<script lang="ts" setup>
import { fetchDataFromDb } from './db';

const data = ref<any[]>([]);

const fetchData = async () => {
  data.value = await fetchDataFromDb();
};

onMounted(() => {
  fetchData(); // åˆæ¬¡åŠ è½½æ•°æ®

  window.addEventListener('message', (event) => {
    if (event.data.type === 'UPDATE_DATA') {
      fetchData(); // åˆ·æ–°æ•°æ®
    }
  });
});
</script>

```

